/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby disabling any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 | *   |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 | *   |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 | *   |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 | *   |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 | *   |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 | *   |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 | *   |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 | *   |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 | *   |     function _burn(address account, uint256 amount) internal virtual {
 278 | *   |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 | *   |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 | *   |         uint256 accountBalance = _balances[account];
 283 | *   |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 | *   |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 | *   |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 | *   |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 | *   |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 |     |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 | *   |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 | *   |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  */
 14 |     | interface IERC20Permit {
 15 |     |     /**
 16 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 17 |     |      * given ``owner``'s signed approval.
 18 |     |      *
 19 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 20 |     |      * ordering also apply here.
 21 |     |      *
 22 |     |      * Emits an {Approval} event.
 23 |     |      *
 24 |     |      * Requirements:
 25 |     |      *
 26 |     |      * - `spender` cannot be the zero address.
 27 |     |      * - `deadline` must be a timestamp in the future.
 28 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 29 |     |      * over the EIP712-formatted function arguments.
 30 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 31 |     |      *
 32 |     |      * For more information on the signature format, see the
 33 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 34 |     |      * section].
 35 |     |      */
 36 |     |     function permit(
 37 |     |         address owner,
 38 |     |         address spender,
 39 |     |         uint256 value,
 40 |     |         uint256 deadline,
 41 |     |         uint8 v,
 42 |     |         bytes32 r,
 43 |     |         bytes32 s
 44 |     |     ) external;
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Returns the current nonce for `owner`. This value must be
 48 |     |      * included whenever a signature is generated for {permit}.
 49 |     |      *
 50 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 51 |     |      * prevents a signature from being used multiple times.
 52 |     |      */
 53 |     |     function nonces(address owner) external view returns (uint256);
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 57 |     |      */
 58 |     |     // solhint-disable-next-line func-name-mixedcase
 59 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 60 |     | }
 61 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 | *   |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 | *   |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 | *   |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 | *   |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 | *   |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 | *   |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 | *   |     ) internal returns (bytes memory) {
 104 | *   |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 | *   |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 | *   |     ) internal returns (bytes memory) {
 134 | *   |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 | *   |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 | *   |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 | *   |     ) internal view returns (bytes memory) {
 201 | *   |         if (success) {
 202 | *   |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 | *   |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Library used to query support of an interface declared via {IERC165}.
  10 |     |  *
  11 |     |  * Note that these functions return the actual result of the query: they do not
  12 |     |  * `revert` if an interface is not supported. It is up to the caller to decide
  13 |     |  * what to do in these cases.
  14 |     |  */
  15 |     | library ERC165Checker {
  16 |     |     // As per the EIP-165 spec, no interface should ever match 0xffffffff
  17 |     |     bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;
  18 |     | 
  19 |     |     /**
  20 |     |      * @dev Returns true if `account` supports the {IERC165} interface.
  21 |     |      */
  22 |     |     function supportsERC165(address account) internal view returns (bool) {
  23 |     |         // Any contract that implements ERC165 must explicitly indicate support of
  24 |     |         // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid
  25 |     |         return
  26 |     |             supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&
  27 |     |             !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns true if `account` supports the interface defined by
  32 |     |      * `interfaceId`. Support for {IERC165} itself is queried automatically.
  33 |     |      *
  34 |     |      * See {IERC165-supportsInterface}.
  35 |     |      */
  36 |     |     function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {
  37 |     |         // query support of both ERC165 as per the spec and support of _interfaceId
  38 |     |         return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Returns a boolean array where each value corresponds to the
  43 |     |      * interfaces passed in and whether they're supported or not. This allows
  44 |     |      * you to batch check interfaces for a contract where your expectation
  45 |     |      * is that some interfaces may not be supported.
  46 |     |      *
  47 |     |      * See {IERC165-supportsInterface}.
  48 |     |      *
  49 |     |      * _Available since v3.4._
  50 |     |      */
  51 |     |     function getSupportedInterfaces(
  52 |     |         address account,
  53 |     |         bytes4[] memory interfaceIds
  54 |     |     ) internal view returns (bool[] memory) {
  55 |     |         // an array of booleans corresponding to interfaceIds and whether they're supported or not
  56 |     |         bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);
  57 |     | 
  58 |     |         // query support of ERC165 itself
  59 |     |         if (supportsERC165(account)) {
  60 |     |             // query support of each interface in interfaceIds
  61 |     |             for (uint256 i = 0; i < interfaceIds.length; i++) {
  62 |     |                 interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);
  63 |     |             }
  64 |     |         }
  65 |     | 
  66 |     |         return interfaceIdsSupported;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns true if `account` supports all the interfaces defined in
  71 |     |      * `interfaceIds`. Support for {IERC165} itself is queried automatically.
  72 |     |      *
  73 |     |      * Batch-querying can lead to gas savings by skipping repeated checks for
  74 |     |      * {IERC165} support.
  75 |     |      *
  76 |     |      * See {IERC165-supportsInterface}.
  77 |     |      */
  78 |     |     function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {
  79 |     |         // query support of ERC165 itself
  80 |     |         if (!supportsERC165(account)) {
  81 |     |             return false;
  82 |     |         }
  83 |     | 
  84 |     |         // query support of each interface in interfaceIds
  85 |     |         for (uint256 i = 0; i < interfaceIds.length; i++) {
  86 |     |             if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {
  87 |     |                 return false;
  88 |     |             }
  89 |     |         }
  90 |     | 
  91 |     |         // all interfaces supported
  92 |     |         return true;
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @notice Query if a contract implements an interface, does not check ERC165 support
  97 |     |      * @param account The address of the contract to query for support of an interface
  98 |     |      * @param interfaceId The interface identifier, as specified in ERC-165
  99 |     |      * @return true if the contract at account indicates support of the interface with
 100 |     |      * identifier interfaceId, false otherwise
 101 |     |      * @dev Assumes that account contains a contract that supports ERC165, otherwise
 102 |     |      * the behavior of this method is undefined. This precondition can be checked
 103 |     |      * with {supportsERC165}.
 104 |     |      *
 105 |     |      * Some precompiled contracts will falsely indicate support for a given interface, so caution
 106 |     |      * should be exercised when using this function.
 107 |     |      *
 108 |     |      * Interface identification is specified in ERC-165.
 109 |     |      */
 110 |     |     function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {
 111 |     |         // prepare call
 112 |     |         bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);
 113 |     | 
 114 |     |         // perform static call
 115 |     |         bool success;
 116 |     |         uint256 returnSize;
 117 |     |         uint256 returnValue;
 118 |     |         assembly {
 119 |     |             success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)
 120 |     |             returnSize := returndatasize()
 121 |     |             returnValue := mload(0x00)
 122 |     |         }
 123 |     | 
 124 |     |         return success && returnSize >= 0x20 && returnValue > 0;
 125 |     |     }
 126 |     | }
 127 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/BondingCurve/BondToken.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | 
   3 |     | /**
   4 |     |  * Created on 2023-07-29 6:08
   5 |     |  * @Summary A smart contract that lets users buy tokens in Linear Curve fashion.
   6 |     |  * @title BondToken
   7 |     |  * @author: c-n-o-t-e
   8 |     |  */
   9 |     | 
  10 |     | pragma solidity 0.8.19;
  11 |     | 
  12 |     | import "./IBondToken.sol";
  13 |     | import "erc-payable-token/contracts/token/ERC1363/ERC1363.sol";
  14 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  15 |     | import "erc-payable-token/contracts/token/ERC1363/IERC1363Spender.sol";
  16 |     | import "erc-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol";
  17 |     | import "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";
  18 |     | 
  19 | *   | contract BondToken is ERC1363, IERC1363Receiver, IERC1363Spender, IBondToken {
  20 |     |     using SafeERC20 for ERC1363;
  21 |     |     using ERC165Checker for address;
  22 |     | 
  23 |     |     ERC1363 public acceptedToken;
  24 | *   |     uint256 public constant INITIAL_PRICE = 1e18;
  25 |     | 
  26 |     |     constructor(address token) ERC20("BondToken", "BT") {
  27 |     |         acceptedToken = ERC1363(token);
  28 |     |     }
  29 |     | 
  30 |     |     /// @inheritdoc IBondToken
  31 | *   |     function calculateBuyPrice(
  32 |     |         uint256 amountToBuy
  33 | *   |     ) public view returns (uint256) {
  34 | *   |         return INITIAL_PRICE + ((totalSupply() + amountToBuy) / 100);
  35 |     |     }
  36 |     | 
  37 |     |     /// @inheritdoc IBondToken
  38 | *   |     function calculateSalePrice(
  39 |     |         uint256 amountToSell
  40 | *   |     ) public view returns (uint256) {
  41 | *   |         return INITIAL_PRICE + ((totalSupply() - amountToSell) / 100);
  42 |     |     }
  43 |     | 
  44 |     |     /// @dev Handles actual buy and sell of bond tokens.
  45 |     |     /// @inheritdoc IERC1363Receiver
  46 | *   |     function onTransferReceived(
  47 |     |         address spender,
  48 |     |         address sender,
  49 |     |         uint256 amount,
  50 |     |         bytes memory data
  51 | *   |     ) public override returns (bytes4) {
  52 | *   |         if (_msgSender() == address(acceptedToken)) {
  53 | *   |             (uint256 amount_, uint256 numberOfTokensToBuy) = _validatePurchase(
  54 | *   |                 data
  55 |     |             );
  56 |     | 
  57 |     |             /// Used to prevent users sending reserve token via transferAndCall.
  58 |     |             /// This will be bypassed if they calculate needed amount to send using calculateBuyPrice()
  59 | *   |             if (amount != amount_)
  60 |     |                 revert BondToken_Sent_Funds_Not_Enough_To_Buy_Token_Amount_User_Desire();
  61 |     | 
  62 | *   |             _mint(sender, numberOfTokensToBuy);
  63 |     | 
  64 | *   |             emit TokensReceived(spender, sender, numberOfTokensToBuy);
  65 | *   |         } else if (_msgSender() == address(this)) {
  66 | *   |             uint256 amountToSend = (calculateSalePrice(amount) * amount) / 1e18;
  67 |     | 
  68 | *   |             _burn(address(this), amount);
  69 | *   |             acceptedToken.safeTransfer(sender, amountToSend);
  70 |     | 
  71 | *   |             emit TokensReceived(spender, sender, amount);
  72 |     |         } else {
  73 |     |             revert BondToken_AcceptedToken_Not_Sender();
  74 |     |         }
  75 |     | 
  76 | *   |         return IERC1363Receiver.onTransferReceived.selector;
  77 |     |     }
  78 |     | 
  79 |     |     /// @dev Ensures _msgSender() is accepted token
  80 |     |     /// @inheritdoc IERC1363Spender
  81 | *   |     function onApprovalReceived(
  82 |     |         address sender,
  83 |     |         uint256 amount,
  84 |     |         bytes memory data
  85 | *   |     ) public override returns (bytes4) {
  86 | *   |         if (_msgSender() != address(acceptedToken))
  87 |     |             revert BondToken_AcceptedToken_Not_Sender();
  88 |     | 
  89 | *   |         emit TokensApproved(sender, amount, data);
  90 | *   |         _approvalReceived(sender, data);
  91 |     | 
  92 | *   |         return IERC1363Spender.onApprovalReceived.selector;
  93 |     |     }
  94 |     | 
  95 |     |     function supportsInterface(
  96 |     |         bytes4 interfaceId
  97 |     |     ) public view virtual override returns (bool) {
  98 |     |         return
  99 |     |             interfaceId == type(IERC1363Receiver).interfaceId ||
 100 |     |             interfaceId == type(IERC1363Spender).interfaceId ||
 101 |     |             super.supportsInterface(interfaceId);
 102 |     |     }
 103 |     | 
 104 |     |     /// @dev Returns number of tokens to buy and amount derived from data.
 105 |     |     /// @param data Data encode with users number of tokens to buy.
 106 |     |     /// @return amount_ amount derived from data.
 107 |     |     /// @return numberOfTokensToBuy number of tokens to buy derived from data.
 108 | *   |     function _validatePurchase(
 109 |     |         bytes memory data
 110 | *   |     ) internal view returns (uint256 amount_, uint256 numberOfTokensToBuy) {
 111 | *   |         numberOfTokensToBuy = abi.decode(data, (uint256));
 112 | *   |         amount_ =
 113 | *   |             (numberOfTokensToBuy * calculateBuyPrice(numberOfTokensToBuy)) /
 114 | *   |             1e18;
 115 |     | 
 116 | *   |         if (numberOfTokensToBuy == 0)
 117 |     |             revert BondToken_Number_Of_Tokens_To_Buy_Cannot_Be_Zero();
 118 |     |     }
 119 |     | 
 120 |     |     /// @dev Get actual amount to buy and calls transferFromAndCall.
 121 |     |     /// @param sender Sender of amount
 122 |     |     /// @param data Data encode with users number of tokens to buy.
 123 | *   |     function _approvalReceived(
 124 |     |         address sender,
 125 |     |         bytes memory data
 126 | *   |     ) internal virtual {
 127 | *   |         (uint256 amount, ) = _validatePurchase(data);
 128 | *   |         acceptedToken.transferFromAndCall(sender, address(this), amount, data);
 129 |     |     }
 130 |     | }
 131 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/BondingCurve/EchidnaBondTest.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "./SetUp.sol";
  5 |     | 
  6 | *r  | contract EchidnaBondTest is SetUp {
  7 | *   |     function sales(uint amount) public {
  8 | *   |         if (amount == 0) amount = 1;
  9 | *   |         if (amount < 1e18) amount = amount * 1e18;
 10 |     | 
 11 | *   |         uint amountPurchased = (bondToken.calculateBuyPrice(amount) * amount) /
 12 | *   |             1e18;
 13 |     | 
 14 | *   |         mintToken(address(this), amountPurchased * 2);
 15 |     | 
 16 | *   |         uint256 bondBalanceBeforeSalesTx = bondToken.balanceOf(address(this));
 17 | *   |         uint256 reserveBalanceBeforeSalesTx = reserveToken.balanceOf(
 18 | *   |             address(this)
 19 |     |         );
 20 |     | 
 21 | *   |         bytes memory data = abi.encode(amount);
 22 |     | 
 23 | *   |         try
 24 | *   |             reserveToken.approveAndCall(
 25 | *   |                 address(bondToken),
 26 | *   |                 type(uint256).max,
 27 | *   |                 data
 28 |     |             )
 29 | *   |         {
 30 | *   |             uint256 bondBalanceAfterBuyTx = bondToken.balanceOf(address(this));
 31 | *   |             uint256 reserveBalanceAfterBuyTx = reserveToken.balanceOf(
 32 | *   |                 address(this)
 33 |     |             );
 34 | *   |             assert(bondBalanceAfterBuyTx == bondBalanceBeforeSalesTx + amount);
 35 |     | 
 36 | *   |             assert(
 37 | *   |                 reserveBalanceAfterBuyTx ==
 38 | *   |                     reserveBalanceBeforeSalesTx - amountPurchased
 39 |     |             );
 40 |     |         } catch (bytes memory err) {
 41 |     |             // Post-condition
 42 |     |             assert(false);
 43 |     |         }
 44 |     | 
 45 | *   |         try bondToken.transferAndCall(address(bondToken), amount, "") {
 46 | *   |             uint256 reserveBalanceAfterSellTx = reserveToken.balanceOf(
 47 | *   |                 address(this)
 48 |     |             );
 49 | *   |             uint256 bondBalanceAfterSellTx = bondToken.balanceOf(address(this));
 50 |     | 
 51 | *   |             assert(reserveBalanceBeforeSalesTx > reserveBalanceAfterSellTx);
 52 | *   |             assert(bondBalanceAfterSellTx == bondBalanceBeforeSalesTx - amount);
 53 |     |         } catch (bytes memory err) {
 54 |     |             // Post-condition
 55 |     |             assert(false);
 56 |     |         }
 57 |     |     }
 58 |     | }
 59 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/BondingCurve/IBondToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | interface IBondToken {
  5 |     |     event TokensReceived(
  6 |     |         address indexed operator,
  7 |     |         address indexed sender,
  8 |     |         uint256 amount
  9 |     |     );
 10 |     | 
 11 |     |     event TokensApproved(address indexed sender, uint256 amount, bytes data);
 12 |     | 
 13 |     |     error BondToken_Delay_Period_Not_Passed();
 14 |     |     error BondToken_AcceptedToken_Not_Sender();
 15 |     |     error BondToken_FirstPurchaseMustTenTokenAndBelow();
 16 |     |     error BondToken_Number_Of_Tokens_To_Buy_Cannot_Be_Zero();
 17 |     |     error BondToken_Sent_Funds_Not_Enough_To_Buy_Token_Amount_User_Desire();
 18 |     | 
 19 |     |     /// @dev calculates price a user will pay for the amount of token user desire.
 20 |     |     /// Using linear bond curve formula p  = mx + b, where:
 21 |     |     /// p = price
 22 |     |     /// m = slope, here we use 1% which is same as dividing by 100 as shown below.
 23 |     |     /// x = bond token supply + amount of token user wants to buy.
 24 |     |     /// b = initial price.
 25 |     |     /// With this formula user pays more reserve token when buying.
 26 |     |     /// @param amountToBuy amount of token user desire.
 27 |     |     function calculateBuyPrice(
 28 |     |         uint256 amountToBuy
 29 |     |     ) external view returns (uint256);
 30 |     | 
 31 |     |     /// @dev calculates price a user will pay for the amount of token user wants to sell back.
 32 |     |     /// Using linear bond curve formula p  = mx + b, where:
 33 |     |     /// p = price
 34 |     |     /// m = slope, here we use 1% which is same as dividing by 100 as shown below.
 35 |     |     /// x = bond token supply - amount of token user wants to buy.
 36 |     |     /// b = initial price.
 37 |     |     /// With this formula user get less reserve token when selling.
 38 |     |     /// @param amountToSell amount of token user wants to sell.
 39 |     |     function calculateSalePrice(
 40 |     |         uint256 amountToSell
 41 |     |     ) external view returns (uint256);
 42 |     | }
 43 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/BondingCurve/ReserveToken.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "erc-payable-token/contracts/token/ERC1363/ERC1363.sol";
  5 |     | 
  6 | *   | contract ReserveToken is ERC1363 {
  7 |     |     constructor() ERC20("ReserveToken", "RT") {}
  8 |     | 
  9 | *   |     function freeMint(address user, uint amount) public {
 10 | *   |         _mint(user, amount);
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/BondingCurve/SetUp.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "./BondToken.sol";
  5 |     | import "./ReserveToken.sol";
  6 |     | 
  7 |     | contract Users {
  8 |     |     function proxy(
  9 |     |         address target,
 10 |     |         bytes memory data
 11 |     |     ) public returns (bool success, bytes memory retData) {
 12 |     |         return target.call(data);
 13 |     |     }
 14 |     | }
 15 |     | 
 16 |     | contract SetUp {
 17 |     |     Users public user;
 18 |     |     BondToken public bondToken;
 19 |     |     ReserveToken public reserveToken;
 20 |     | 
 21 |     |     constructor() {
 22 |     |         user = new Users();
 23 |     |         reserveToken = new ReserveToken();
 24 |     |         bondToken = new BondToken(address(reserveToken));
 25 |     |     }
 26 |     | 
 27 | *   |     function mintToken(address addr, uint amount) public {
 28 | *r  |         reserveToken.freeMint(addr, amount);
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/Dex/Dex.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | import "@openzeppelin/contracts/access/Ownable.sol";
  7 |     | 
  8 |     | // import "./SwappableToken.sol";
  9 |     | 
 10 |     | contract Dex is Ownable {
 11 |     |     address public token1;
 12 |     |     address public token2;
 13 |     | 
 14 |     |     constructor() {}
 15 |     | 
 16 |     |     function setTokens(address _token1, address _token2) public onlyOwner {
 17 |     |         token1 = _token1;
 18 |     |         token2 = _token2;
 19 |     |     }
 20 |     | 
 21 |     |     function addLiquidity(address token_address, uint amount) public onlyOwner {
 22 |     |         IERC20(token_address).transferFrom(msg.sender, address(this), amount);
 23 |     |     }
 24 |     | 
 25 |     |     function swap(address from, address to, uint amount) public {
 26 |     |         require(
 27 |     |             (from == token1 && to == token2) ||
 28 |     |                 (from == token2 && to == token1),
 29 |     |             "Invalid tokens"
 30 |     |         );
 31 |     |         require(
 32 |     |             IERC20(from).balanceOf(msg.sender) >= amount,
 33 |     |             "Not enough to swap"
 34 |     |         );
 35 |     |         uint swapAmount = getSwapPrice(from, to, amount);
 36 |     |         IERC20(from).transferFrom(msg.sender, address(this), amount);
 37 |     |         IERC20(to).approve(address(this), swapAmount);
 38 |     |         IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
 39 |     |     }
 40 |     | 
 41 |     |     function getSwapPrice(
 42 |     |         address from,
 43 |     |         address to,
 44 |     |         uint amount
 45 |     |     ) public view returns (uint) {
 46 |     |         return ((amount * IERC20(to).balanceOf(address(this))) /
 47 |     |             IERC20(from).balanceOf(address(this)));
 48 |     |     }
 49 |     | 
 50 |     |     function approve(address spender, uint amount) public {
 51 |     |         SwappableToken(token1).approve(msg.sender, spender, amount);
 52 |     |         SwappableToken(token2).approve(msg.sender, spender, amount);
 53 |     |     }
 54 |     | 
 55 |     |     function balanceOf(
 56 |     |         address token,
 57 |     |         address account
 58 |     |     ) public view returns (uint) {
 59 |     |         return IERC20(token).balanceOf(account);
 60 |     |     }
 61 |     | }
 62 |     | 
 63 |     | contract SwappableToken is ERC20 {
 64 |     |     address private _dex;
 65 |     | 
 66 |     |     constructor(
 67 |     |         address dexInstance,
 68 |     |         string memory name,
 69 |     |         string memory symbol,
 70 |     |         uint256 initialSupply
 71 |     |     ) ERC20(name, symbol) {
 72 |     |         _mint(msg.sender, initialSupply);
 73 |     |         _dex = dexInstance;
 74 |     |     }
 75 |     | 
 76 |     |     function approve(address owner, address spender, uint256 amount) public {
 77 |     |         require(owner != _dex, "InvalidApprover");
 78 |     |         super._approve(owner, spender, amount);
 79 |     |     }
 80 |     | }
 81 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/Dex/EchidnaDexTest.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "./SetUp.sol";
  5 |     | 
  6 |     | contract EchidnaDexTest is SetUp {
  7 |     |     function balance() public {
  8 |     |         dex.swap(
  9 |     |             dex.token1(),
 10 |     |             dex.token2(),
 11 |     |             dex.balanceOf(dex.token1(), address(this))
 12 |     |         );
 13 |     | 
 14 |     |         dex.swap(
 15 |     |             dex.token2(),
 16 |     |             dex.token1(),
 17 |     |             dex.balanceOf(dex.token2(), address(this))
 18 |     |         );
 19 |     | 
 20 |     |         // Where a dex has 100 tokens of token1 and token 2,
 21 |     |         // a user swapping between token1 and token2 with 10 tokens each.
 22 |     |         // An ideal Dex balance for either of the tokens shouldn't go below 70.
 23 |     |         assert(dex.balanceOf(dex.token1(), address(dex)) > 70);
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/Dex/SetUp.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.19;
  3 |     | 
  4 |     | import "./Dex.sol";
  5 |     | 
  6 |     | contract SetUp {
  7 |     |     Dex public dex;
  8 |     |     SwappableToken public token;
  9 |     |     SwappableToken public token1;
 10 |     | 
 11 |     |     constructor() {
 12 |     |         dex = new Dex();
 13 |     | 
 14 |     |         token = new SwappableToken(address(dex), "Test Token 1", "TT1", 110);
 15 |     |         token1 = new SwappableToken(address(dex), "Test Token 2", "TT2", 110);
 16 |     | 
 17 |     |         dex.setTokens(address(token), address(token1));
 18 |     |         dex.approve(address(dex), type(uint).max);
 19 |     | 
 20 |     |         dex.addLiquidity(address(token), 100);
 21 |     |         dex.addLiquidity(address(token1), 100);
 22 |     | 
 23 |     |         dex.renounceOwnership();
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/EchidnaExercise/mintable.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./task.sol";
  4 |     | 
  5 |     | contract MintableToken is Task {
  6 |     |     int256 public totalMinted;
  7 |     |     int256 public totalMintable;
  8 |     | 
  9 |     |     constructor(int256 totalMintable_) {
 10 |     |         totalMintable = totalMintable_;
 11 |     |     }
 12 |     | 
 13 |     |     function mint(uint256 value) public onlyOwner {
 14 |     |         require(int256(value) + totalMinted < totalMintable);
 15 |     | 
 16 |     |         // fix for test2
 17 |     |         require(
 18 |     |             balances[msg.sender] + value <= 10_000,
 19 |     |             "above balance allowed"
 20 |     |         );
 21 |     | 
 22 |     |         totalMinted += int256(value);
 23 |     | 
 24 |     |         balances[msg.sender] += value;
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/EchidnaExercise/task.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract Ownable {
  5 |     |     address public owner = msg.sender;
  6 |     | 
  7 |     |     // fix for test1
  8 |     |     // function Owner() public {
  9 |     |     //     owner = msg.sender;
 10 |     |     // }
 11 |     | 
 12 |     |     function transferOwnership(address newOwner) public onlyOwner {
 13 |     |         owner = newOwner;
 14 |     |     }
 15 |     | 
 16 |     |     modifier onlyOwner() {
 17 |     |         require(msg.sender == owner, "Ownable: Caller is not the owner.");
 18 |     |         _;
 19 |     |     }
 20 |     | }
 21 |     | 
 22 |     | contract Pausable is Ownable {
 23 |     |     bool private _paused;
 24 |     | 
 25 |     |     function paused() public view returns (bool) {
 26 |     |         return _paused;
 27 |     |     }
 28 |     | 
 29 |     |     function pause() public onlyOwner {
 30 |     |         _paused = true;
 31 |     |     }
 32 |     | 
 33 |     |     function resume() public onlyOwner {
 34 |     |         _paused = false;
 35 |     |     }
 36 |     | 
 37 |     |     modifier whenNotPaused() {
 38 |     |         require(!_paused, "Pausable: Contract is paused.");
 39 |     |         _;
 40 |     |     }
 41 |     | }
 42 |     | 
 43 |     | contract Task is Ownable, Pausable {
 44 |     |     mapping(address => uint256) public balances;
 45 |     | 
 46 |     |     function transfer(address to, uint256 value) public virtual whenNotPaused {
 47 |     |         require(balances[msg.sender] >= value, "above user balance"); // fix for test.sol and test3.sol or remove unchecked
 48 |     |         // unchecked to save gas
 49 |     |         unchecked {
 50 |     |             balances[msg.sender] -= value;
 51 |     |             balances[to] += value;
 52 |     |         }
 53 |     |     }
 54 |     | }
 55 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/EchidnaExercise/test.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./task.sol";
  5 |     | 
  6 |     | contract TestToken is Task {
  7 |     |     address private _echidna = tx.origin;
  8 |     | 
  9 |     |     constructor() {
 10 |     |         balances[_echidna] = 10_000;
 11 |     |     }
 12 |     | 
 13 |     |     function echidna_test_balance() public view returns (bool) {
 14 |     |         return balances[_echidna] <= 10000;
 15 |     |     }
 16 |     | }
 17 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/EchidnaExercise/test1.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./task.sol";
  4 |     | 
  5 |     | contract TestToken is Task {
  6 |     |     constructor() {
  7 |     |         pause(); // pause the contract
  8 |     |         owner = address(0); // lose ownership
  9 |     |     }
 10 |     | 
 11 |     |     function echidna_cannot_be_unpause() public view returns (bool) {
 12 |     |         return (paused() == true);
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/EchidnaExercise/test2.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./mintable.sol";
  4 |     | 
  5 |     | contract TestToken is MintableToken {
  6 |     |     address echidna = msg.sender;
  7 |     | 
  8 |     |     // TODO: update the constructor
  9 |     |     constructor() MintableToken(10_000) {
 10 |     |         owner = echidna;
 11 |     |     }
 12 |     | 
 13 |     |     function echidna_test_balance() public view returns (bool) {
 14 |     |         return balances[msg.sender] <= 10_000;
 15 |     |     }
 16 |     | }
 17 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/EchidnaExercise/test3.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./task.sol";
  4 |     | 
  5 |     | contract TestToken is Task {
  6 |     |     function transfer(address to, uint256 value) public override {
  7 |     |         uint256 senderBalancerBeforeTx = balances[msg.sender];
  8 |     |         uint256 receiverBalancerBeforeTx = balances[to];
  9 |     | 
 10 |     |         super.transfer(to, value);
 11 |     | 
 12 |     |         uint256 senderBalancerAftereTx = balances[msg.sender];
 13 |     |         uint256 receiverBalancerAftereTx = balances[to];
 14 |     | 
 15 |     |         assert(senderBalancerBeforeTx >= senderBalancerAftereTx);
 16 |     |         assert(receiverBalancerAftereTx >= receiverBalancerBeforeTx);
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/TokenWhaleChallenge/EchidnaWhaleTest.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./FixedTokenWhaleChallenge.sol";
  4 |     | 
  5 |     | contract EchidnaWhaleTest is FixedTokenWhaleChallenge {
  6 |     |     constructor() FixedTokenWhaleChallenge(msg.sender) {}
  7 |     | 
  8 |     |     function echidna_test_balance() public view returns (bool) {
  9 |     |         return !isComplete();
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/TokenWhaleChallenge/FixedTokenWhaleChallenge.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | contract FixedTokenWhaleChallenge {
  4 |     |     address player;
  5 |     | 
  6 |     |     uint256 public totalSupply;
  7 |     |     mapping(address => uint256) public balanceOf;
  8 |     |     mapping(address => mapping(address => uint256)) public allowance;
  9 |     | 
 10 |     |     string public name = "Simple ERC20 Token";
 11 |     |     string public symbol = "SET";
 12 |     |     uint8 public decimals = 18;
 13 |     | 
 14 |     |     constructor(address _player) {
 15 |     |         player = _player;
 16 |     |         totalSupply = 1000;
 17 |     |         balanceOf[player] = 1000;
 18 |     |     }
 19 |     | 
 20 |     |     function isComplete() public view returns (bool) {
 21 |     |         return balanceOf[player] >= 1000000;
 22 |     |     }
 23 |     | 
 24 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 25 |     | 
 26 |     |     function _transfer(address from, address to, uint256 value) internal {
 27 |     |         unchecked {
 28 |     |             balanceOf[from] -= value;
 29 |     |             balanceOf[to] += value;
 30 |     |         }
 31 |     | 
 32 |     |         emit Transfer(from, to, value);
 33 |     |     }
 34 |     | 
 35 |     |     function transfer(address to, uint256 value) public {
 36 |     |         require(balanceOf[msg.sender] >= value);
 37 |     |         require(balanceOf[to] + value >= balanceOf[to]);
 38 |     | 
 39 |     |         _transfer(msg.sender, to, value);
 40 |     |     }
 41 |     | 
 42 |     |     event Approval(
 43 |     |         address indexed owner,
 44 |     |         address indexed spender,
 45 |     |         uint256 value
 46 |     |     );
 47 |     | 
 48 |     |     function approve(address spender, uint256 value) public {
 49 |     |         allowance[msg.sender][spender] = value;
 50 |     |         emit Approval(msg.sender, spender, value);
 51 |     |     }
 52 |     | 
 53 |     |     function transferFrom(address from, address to, uint256 value) public {
 54 |     |         require(balanceOf[from] >= value);
 55 |     |         require(balanceOf[to] + value >= balanceOf[to]);
 56 |     |         require(allowance[from][msg.sender] >= value);
 57 |     | 
 58 |     |         allowance[from][msg.sender] -= value;
 59 |     |         _transfer(from, to, value);
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/contracts/TokenWhaleChallenge/TokenWhaleChallenge.sol
  1 |     | pragma solidity 0.8.19;
  2 |     | 
  3 |     | contract TokenWhaleChallenge {
  4 |     |     address player;
  5 |     | 
  6 |     |     uint256 public totalSupply;
  7 |     |     mapping(address => uint256) public balanceOf;
  8 |     |     mapping(address => mapping(address => uint256)) public allowance;
  9 |     | 
 10 |     |     string public name = "Simple ERC20 Token";
 11 |     |     string public symbol = "SET";
 12 |     |     uint8 public decimals = 18;
 13 |     | 
 14 |     |     constructor(address _player) {
 15 |     |         player = _player;
 16 |     |         totalSupply = 1000;
 17 |     |         balanceOf[player] = 1000;
 18 |     |     }
 19 |     | 
 20 |     |     function isComplete() public view returns (bool) {
 21 |     |         return balanceOf[player] >= 1000000;
 22 |     |     }
 23 |     | 
 24 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 25 |     | 
 26 |     |     function _transfer(address to, uint256 value) internal {
 27 |     |         unchecked {
 28 |     |             balanceOf[msg.sender] -= value;
 29 |     |             balanceOf[to] += value;
 30 |     |         }
 31 |     | 
 32 |     |         emit Transfer(msg.sender, to, value);
 33 |     |     }
 34 |     | 
 35 |     |     function transfer(address to, uint256 value) public {
 36 |     |         require(balanceOf[msg.sender] >= value);
 37 |     |         require(balanceOf[to] + value >= balanceOf[to]);
 38 |     | 
 39 |     |         _transfer(to, value);
 40 |     |     }
 41 |     | 
 42 |     |     event Approval(
 43 |     |         address indexed owner,
 44 |     |         address indexed spender,
 45 |     |         uint256 value
 46 |     |     );
 47 |     | 
 48 |     |     function approve(address spender, uint256 value) public {
 49 |     |         allowance[msg.sender][spender] = value;
 50 |     |         emit Approval(msg.sender, spender, value);
 51 |     |     }
 52 |     | 
 53 |     |     function transferFrom(address from, address to, uint256 value) public {
 54 |     |         require(balanceOf[from] >= value);
 55 |     |         require(balanceOf[to] + value >= balanceOf[to]);
 56 |     |         require(allowance[from][msg.sender] >= value);
 57 |     | 
 58 |     |         allowance[from][msg.sender] -= value;
 59 |     |         _transfer(to, value);
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/erc-payable-token/contracts/token/ERC1363/ERC1363.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
   6 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
   7 |     | import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
   8 |     | 
   9 |     | import {Address} from "@openzeppelin/contracts/utils/Address.sol";
  10 |     | 
  11 |     | import {IERC1363} from "./IERC1363.sol";
  12 |     | import {IERC1363Receiver} from "./IERC1363Receiver.sol";
  13 |     | import {IERC1363Spender} from "./IERC1363Spender.sol";
  14 |     | 
  15 |     | /**
  16 |     |  * @title ERC1363
  17 |     |  * @dev Implementation of an ERC1363 interface.
  18 |     |  */
  19 |     | abstract contract ERC1363 is ERC20, IERC1363, ERC165 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev See {IERC165-supportsInterface}.
  24 |     |      */
  25 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  26 |     |         return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);
  27 |     |     }
  28 |     | 
  29 |     |     /**
  30 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  31 |     |      * @param to The address to transfer to.
  32 |     |      * @param amount The amount to be transferred.
  33 |     |      * @return A boolean that indicates if the operation was successful.
  34 |     |      */
  35 |     |     function transferAndCall(address to, uint256 amount) public virtual override returns (bool) {
  36 |     |         return transferAndCall(to, amount, "");
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  41 |     |      * @param to The address to transfer to
  42 |     |      * @param amount The amount to be transferred
  43 |     |      * @param data Additional data with no specified format
  44 |     |      * @return A boolean that indicates if the operation was successful.
  45 |     |      */
  46 | *   |     function transferAndCall(address to, uint256 amount, bytes memory data) public virtual override returns (bool) {
  47 | *   |         transfer(to, amount);
  48 | *   |         require(_checkOnTransferReceived(_msgSender(), to, amount, data), "ERC1363: receiver returned wrong data");
  49 | *   |         return true;
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
  54 |     |      * @param from The address which you want to send tokens from
  55 |     |      * @param to The address which you want to transfer to
  56 |     |      * @param amount The amount of tokens to be transferred
  57 |     |      * @return A boolean that indicates if the operation was successful.
  58 |     |      */
  59 |     |     function transferFromAndCall(address from, address to, uint256 amount) public virtual override returns (bool) {
  60 |     |         return transferFromAndCall(from, to, amount, "");
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
  65 |     |      * @param from The address which you want to send tokens from
  66 |     |      * @param to The address which you want to transfer to
  67 |     |      * @param amount The amount of tokens to be transferred
  68 |     |      * @param data Additional data with no specified format
  69 |     |      * @return A boolean that indicates if the operation was successful.
  70 |     |      */
  71 | *   |     function transferFromAndCall(
  72 |     |         address from,
  73 |     |         address to,
  74 |     |         uint256 amount,
  75 |     |         bytes memory data
  76 | *   |     ) public virtual override returns (bool) {
  77 | *   |         transferFrom(from, to, amount);
  78 | *   |         require(_checkOnTransferReceived(from, to, amount, data), "ERC1363: receiver returned wrong data");
  79 | *   |         return true;
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
  84 |     |      * @param spender The address allowed to transfer to
  85 |     |      * @param amount The amount allowed to be transferred
  86 |     |      * @return A boolean that indicates if the operation was successful.
  87 |     |      */
  88 |     |     function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {
  89 |     |         return approveAndCall(spender, amount, "");
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
  94 |     |      * @param spender The address allowed to transfer to.
  95 |     |      * @param amount The amount allowed to be transferred.
  96 |     |      * @param data Additional data with no specified format.
  97 |     |      * @return A boolean that indicates if the operation was successful.
  98 |     |      */
  99 | *   |     function approveAndCall(address spender, uint256 amount, bytes memory data) public virtual override returns (bool) {
 100 | *   |         approve(spender, amount);
 101 | *   |         require(_checkOnApprovalReceived(spender, amount, data), "ERC1363: spender returned wrong data");
 102 | *   |         return true;
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.
 107 |     |      *  The call is not executed if the target address is not a contract.
 108 |     |      * @param sender address Representing the previous owner of the given token amount
 109 |     |      * @param recipient address Target address that will receive the tokens
 110 |     |      * @param amount uint256 The amount mount of tokens to be transferred
 111 |     |      * @param data bytes Optional data to send along with the call
 112 |     |      * @return whether the call correctly returned the expected magic value
 113 |     |      */
 114 | *   |     function _checkOnTransferReceived(
 115 |     |         address sender,
 116 |     |         address recipient,
 117 |     |         uint256 amount,
 118 |     |         bytes memory data
 119 | *   |     ) internal virtual returns (bool) {
 120 | *   |         if (!recipient.isContract()) {
 121 |     |             revert("ERC1363: transfer to non contract address");
 122 |     |         }
 123 |     | 
 124 | *   |         try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {
 125 | *   |             return retval == IERC1363Receiver.onTransferReceived.selector;
 126 |     |         } catch (bytes memory reason) {
 127 |     |             if (reason.length == 0) {
 128 |     |                 revert("ERC1363: transfer to non ERC1363Receiver implementer");
 129 |     |             } else {
 130 |     |                 /// @solidity memory-safe-assembly
 131 |     |                 assembly {
 132 |     |                     revert(add(32, reason), mload(reason))
 133 |     |                 }
 134 |     |             }
 135 |     |         }
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.
 140 |     |      *  The call is not executed if the target address is not a contract.
 141 |     |      * @param spender address The address which will spend the funds
 142 |     |      * @param amount uint256 The amount of tokens to be spent
 143 |     |      * @param data bytes Optional data to send along with the call
 144 |     |      * @return whether the call correctly returned the expected magic value
 145 |     |      */
 146 | *   |     function _checkOnApprovalReceived(
 147 |     |         address spender,
 148 |     |         uint256 amount,
 149 |     |         bytes memory data
 150 | *   |     ) internal virtual returns (bool) {
 151 | *   |         if (!spender.isContract()) {
 152 |     |             revert("ERC1363: approve a non contract address");
 153 |     |         }
 154 |     | 
 155 | *   |         try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {
 156 | *   |             return retval == IERC1363Spender.onApprovalReceived.selector;
 157 |     |         } catch (bytes memory reason) {
 158 |     |             if (reason.length == 0) {
 159 |     |                 revert("ERC1363: approve a non ERC1363Spender implementer");
 160 |     |             } else {
 161 |     |                 /// @solidity memory-safe-assembly
 162 |     |                 assembly {
 163 |     |                     revert(add(32, reason), mload(reason))
 164 |     |                 }
 165 |     |             }
 166 |     |         }
 167 |     |     }
 168 |     | }
 169 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/erc-payable-token/contracts/token/ERC1363/IERC1363.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title IERC1363 Interface
 10 |     |  * @dev Interface of an ERC1363 compliant contract, as defined in the https://eips.ethereum.org/EIPS/eip-1363[EIP].
 11 |     |  */
 12 |     | interface IERC1363 is IERC20, IERC165 {
 13 |     |     /*
 14 |     |      * Note: the ERC-165 identifier for this interface is 0xb0202a11.
 15 |     |      * 0xb0202a11 ===
 16 |     |      *   bytes4(keccak256('transferAndCall(address,uint256)')) ^
 17 |     |      *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^
 18 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^
 19 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^
 20 |     |      *   bytes4(keccak256('approveAndCall(address,uint256)')) ^
 21 |     |      *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))
 22 |     |      */
 23 |     | 
 24 |     |     /**
 25 |     |      * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver.
 26 |     |      * @param to address The address which you want to transfer to
 27 |     |      * @param amount uint256 The amount of tokens to be transferred
 28 |     |      * @return true unless throwing
 29 |     |      */
 30 |     |     function transferAndCall(address to, uint256 amount) external returns (bool);
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver.
 34 |     |      * @param to address The address which you want to transfer to
 35 |     |      * @param amount uint256 The amount of tokens to be transferred
 36 |     |      * @param data bytes Additional data with no specified format, sent in call to `to`
 37 |     |      * @return true unless throwing
 38 |     |      */
 39 |     |     function transferAndCall(address to, uint256 amount, bytes calldata data) external returns (bool);
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver.
 43 |     |      * @param from address The address which you want to send tokens from
 44 |     |      * @param to address The address which you want to transfer to
 45 |     |      * @param amount uint256 The amount of tokens to be transferred
 46 |     |      * @return true unless throwing
 47 |     |      */
 48 |     |     function transferFromAndCall(address from, address to, uint256 amount) external returns (bool);
 49 |     | 
 50 |     |     /**
 51 |     |      * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver.
 52 |     |      * @param from address The address which you want to send tokens from
 53 |     |      * @param to address The address which you want to transfer to
 54 |     |      * @param amount uint256 The amount of tokens to be transferred
 55 |     |      * @param data bytes Additional data with no specified format, sent in call to `to`
 56 |     |      * @return true unless throwing
 57 |     |      */
 58 |     |     function transferFromAndCall(address from, address to, uint256 amount, bytes calldata data) external returns (bool);
 59 |     | 
 60 |     |     /**
 61 |     |      * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender
 62 |     |      * and then call `onApprovalReceived` on spender.
 63 |     |      * Beware that changing an allowance with this method brings the risk that someone may use both the old
 64 |     |      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
 65 |     |      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
 66 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 67 |     |      * @param spender address The address which will spend the funds
 68 |     |      * @param amount uint256 The amount of tokens to be spent
 69 |     |      */
 70 |     |     function approveAndCall(address spender, uint256 amount) external returns (bool);
 71 |     | 
 72 |     |     /**
 73 |     |      * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender
 74 |     |      * and then call `onApprovalReceived` on spender.
 75 |     |      * Beware that changing an allowance with this method brings the risk that someone may use both the old
 76 |     |      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
 77 |     |      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
 78 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 79 |     |      * @param spender address The address which will spend the funds
 80 |     |      * @param amount uint256 The amount of tokens to be spent
 81 |     |      * @param data bytes Additional data with no specified format, sent in call to `spender`
 82 |     |      */
 83 |     |     function approveAndCall(address spender, uint256 amount, bytes calldata data) external returns (bool);
 84 |     | }
 85 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/erc-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title IERC1363Receiver interface
  7 |     |  * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`
  8 |     |  *  from ERC1363 token contracts.
  9 |     |  */
 10 |     | interface IERC1363Receiver {
 11 |     |     /*
 12 |     |      * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.
 13 |     |      * 0x88a7ca5c === bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))
 14 |     |      */
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Handle the receipt of ERC1363 tokens.
 18 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 19 |     |      * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the
 20 |     |      * transfer. Return of other than the magic value MUST result in the
 21 |     |      * transaction being reverted.
 22 |     |      * Note: the token contract address is always the message sender.
 23 |     |      * @param spender address The address which called `transferAndCall` or `transferFromAndCall` function
 24 |     |      * @param sender address The address which are token transferred from
 25 |     |      * @param amount uint256 The amount of tokens transferred
 26 |     |      * @param data bytes Additional data with no specified format
 27 |     |      * @return `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))` unless throwing
 28 |     |      */
 29 |     |     function onTransferReceived(
 30 |     |         address spender,
 31 |     |         address sender,
 32 |     |         uint256 amount,
 33 |     |         bytes calldata data
 34 |     |     ) external returns (bytes4);
 35 |     | }
 36 |     | 

/Users/macbook/Documents/Blockchain/Rare/RareSkills/Echidna/node_modules/erc-payable-token/contracts/token/ERC1363/IERC1363Spender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title ERC1363Spender interface
  7 |     |  * @dev Interface for any contract that wants to support `approveAndCall`
  8 |     |  *  from ERC1363 token contracts.
  9 |     |  */
 10 |     | interface IERC1363Spender {
 11 |     |     /*
 12 |     |      * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.
 13 |     |      * 0x7b04a2d0 === bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))
 14 |     |      */
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Handle the approval of ERC1363 tokens.
 18 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 19 |     |      * after an `approve`. This function MAY throw to revert and reject the
 20 |     |      * approval. Return of other than the magic value MUST result in the
 21 |     |      * transaction being reverted.
 22 |     |      * Note: the token contract address is always the message sender.
 23 |     |      * @param sender address The address which called `approveAndCall` function
 24 |     |      * @param amount uint256 The amount of tokens to be spent
 25 |     |      * @param data bytes Additional data with no specified format
 26 |     |      * @return `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))` unless throwing
 27 |     |      */
 28 |     |     function onApprovalReceived(address sender, uint256 amount, bytes calldata data) external returns (bytes4);
 29 |     | }
 30 |     | 

